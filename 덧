#include <stdio.h>
#include <stdlib.h> // strtod (문자열을 double로 변환)
#include <string.h> // strchr (문자 검색)
#include <ctype.h>  // isdigit (숫자인지 확인)
#include <math.h>
#include <stdbool.h>

// --- 1. 행렬 연산 함수들 ---

/**
 * @brief 행렬을 [[...], [...]] 형식으로 인쇄
 */
void print_matrix(int rows, int cols, double M[rows][cols]) {
    printf("[");
    for (int i = 0; i < rows; i++) {
        printf("[");
        for (int j = 0; j < cols; j++) {
            printf("%.1f", M[i][j]);
            if (j < cols - 1) printf(", ");
        }
        printf("]");
        if (i < rows - 1) printf(", ");
    }
    printf("]\n");
}

/**
 * @brief 행렬 덧셈 (C = A + B).
 */
int add_matrices(int rows, int cols, double A[rows][cols], double B[rows][cols], double C[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
    return 1;
}

/**
 * @brief 스칼라 곱 (C = k * A)
 */
void scalar_multiply(int rows, int cols, double A[rows][cols], double k, double C[rows][cols]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            C[i][j] = k * A[i][j];
        }
    }
}

/**
 * @brief 전치 행렬 (C_T = A^T).
 */
void transpose_matrix(int R_in, int C_in, double A[R_in][C_in], double C_T[C_in][R_in]) {
    for (int i = 0; i < R_in; i++) {
        for (int j = 0; j < C_in; j++) {
            C_T[j][i] = A[i][j];
        }
    }
}

/**
 * @brief [신규] 행렬 곱셈 (C = A * B).
 * @param M A의 행 수
 * @param N A의 열 수 (이자 B의 행 수)
 * @param P B의 열 수
 */
int multiply_matrices(int M, int N, int P, double A[M][N], double B[N][P], double C[M][P]) {
    // 3중 반복문 (i, j, k)
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < P; j++) {
            // C[i][j] (내적) 계산 전 0.0으로 초기화
            C[i][j] = 0.0;
            for (int k = 0; k < N; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return 1;
}


// --- 2. 핵심 파싱 로직 ---

/**
 * @brief "[[1, 2], [3, 4]]" 같은 문자열을 파싱
 */
int parse_matrix_string(char* str, double* data_out, int* rows_out, int* cols_out) {
    int r = 0, c = 0, c_temp = 0, data_index = 0;
    
    char* p = strchr(str, '[');
    if (p == NULL) return 0;
    p++; 

    while (*p == '[') {
        r++;
        p++; 
        c_temp = 0;

        while (*p != ']' && *p != '\0') {
            double val = strtod(p, &p);
            data_out[data_index++] = val;
            c_temp++;
            while (*p == ' ' || *p == ',') p++;
        }
        if (*p == '\0') return 0;
        p++; 
        
        if (r == 1) {
            c = c_temp;
        } else if (c_temp != c) {
            return 0; // 행마다 열 개수가 다름
        }
        while (*p == ' ' || *p == ',') p++;
    }

    *rows_out = r;
    *cols_out = c;
    return (r > 0 && c > 0);
}

/**
 * @brief "k = 2.0" 같은 문자열에서 숫자만 파싱
 */
double parse_scalar_string(char* str) {
    char* p = str;
    while (*p != '\0' && !isdigit(*p) && *p != '-' && *p != '.') {
        p++;
    }
    return strtod(p, NULL);
}


// --- 3. 메인 함수 ---
int main() {
    char buffer_A[1024], buffer_B[1024], buffer_k[100];
    
    double temp_A[100]; // 1D 임시 저장
    double temp_B[100];
    
    int R_A, C_A, R_B, C_B; // A (R_A x C_A), B (R_B x C_B)
    double k;

    // --- 행렬 A 입력 및 파싱 ---
    printf("A = ");
    fgets(buffer_A, 1024, stdin);
    if (!parse_matrix_string(buffer_A, temp_A, &R_A, &C_A)) {
        printf("오류: 행렬 A의 형식이 잘못되었습니다.\n");
        return 1;
    }
    
    // --- 행렬 B 입력 및 파싱 ---
    printf("B = ");
    fgets(buffer_B, 1024, stdin);
    if (!parse_matrix_string(buffer_B, temp_B, &R_B, &C_B)) {
        printf("오류: 행렬 B의 형식이 잘못되었습니다.\n");
        return 1;
    }

    // --- 스칼라 k 입력 및 파싱 ---
    printf("k = ");
    fgets(buffer_k, 100, stdin);
    k = parse_scalar_string(buffer_k);

    // --- VLA 선언 및 데이터 복사 ---
    double A[R_A][C_A];
    double B[R_B][C_B];

    for (int i = 0; i < R_A; i++) {
        for (int j = 0; j < C_A; j++) {
            A[i][j] = temp_A[i * C_A + j];
        }
    }
    for (int i = 0; i < R_B; i++) {
        for (int j = 0; j < C_B; j++) {
            B[i][j] = temp_B[i * C_B + j];
        }
    }
    
    // --- 계산 결과 출력 ---
    printf("\n--- 계산 결과 ---\n");

    // A + B
    printf("A + B = ");
    if (R_A != R_B || C_A != C_B) {
        printf("[오류: 덧셈을 위해 행렬의 차원이 같아야 합니다.]\n");
    } else {
        double C_add[R_A][C_A];
        add_matrices(R_A, C_A, A, B, C_add);
        print_matrix(R_A, C_A, C_add);
    }

    // k * A
    printf("k * A = ");
    double C_scalar[R_A][C_A];
    scalar_multiply(R_A, C_A, A, k, C_scalar);
    print_matrix(R_A, C_A, C_scalar);

    // A^T
    printf("A^T   = ");
    double A_T[C_A][R_A]; // C_A x R_A
    transpose_matrix(R_A, C_A, A, A_T);
    print_matrix(C_A, R_A, A_T);

    // [신규] A * B (행렬 곱셈)
    printf("A * B = ");
    
    // **요구사항: 곱셈 조건(A의 열 == B의 행) 확인**
    if (C_A != R_B) {
        printf("[오류: 곱셈 불가 (A의 열 %d != B의 행 %d)]\n", C_A, R_B);
    } else {
        // A (R_A x C_A) * B (R_B x C_B) = C (R_A x C_B)
        // M = R_A, N = C_A (or R_B), P = C_B
        double C_mul[R_A][C_B]; // 결과 행렬 (R_A x C_B)
        
        multiply_matrices(R_A, C_A, C_B, A, B, C_mul);
        print_matrix(R_A, C_B, C_mul); // 결과 행렬 크기로 출력
    }

    return 0;
}
